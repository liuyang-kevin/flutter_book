# GUI编程中Canvas是图像的载体。 
越学ui越基础，最后走到色彩，线条，美术，艺术上。还要学数学，几何算法。

canvas 便是这个承载这些内容的地方。

canvas英文本意是画布，油画中的那块帆布画板。在不同的GUI库中，canvas几乎是一个必有名词。与之伴生的还有一个painter的单词。也就是绘制的画笔。

用全局观来看，所有的GUI lib产生的UI，都有这么一个基本逻辑：

1. 程序在某个时机，切入一段绘制或者叫渲染的程序入口（render）
2. 创建、或者获得canvas对象，
    * 其实也就是屏幕的一块具体区域或者是全屏幕
    * 一般还会有对于整个屏幕的偏移量 （Offset）或者坐标 position
3. 新建、获取画笔painter
4. 使用painter在canvas上进行Path路径，像素图Image的绘制，
5. 上一步，不断重复，直至完成一次绘制操作（draw）
6. 本次绘制完成，等待下次render的时机。

抛开渲染程序的入口点与时机。每一次的canvas绘制，是一个完整的绘画过程。最终结果是一张静态的图片，存放到内存之中，然后被显示到屏幕上。

如果我们需要一个动态、持续变化的效果。那么我们必然需要多次使用上述流程。其实现方案一般分为两种：
1. 自己制造timer或loop
2. 借用系统提供的timer或loop

从而不断的触发canvas的绘制过程。

# Canvas与Painter之间的桥梁 - Path 与 Color
当你拿起一支笔，轻轻划过一张白纸，得到了黑色的线条。

从这个例子当中，纸上的*黑色的线条*可以分解出两种要素：
* 线条 - 路径 Path
* 黑色 - 颜色 Color

如果细想这条黑线，其实还有个容易被忽略的问题，现实中承载颜色的东西，一定有： 面积；

所以，这里包含2个问题。一个是数学上的图形，一个是现实中的图形。而计算机恰好就包含了这两个方面。

* 当程序正在运行，一切的图形并没有实体，都是数学意义上的图形，存在于硬盘，内存，cpu等硬件之间以程序作为载体。
* 当程序运行完毕，一大段的bit stream随着电路冲入显示器，我们又得到了现实中的图形，以屏幕等为载体。

回归到Canvas，回归到程序上。这里一般就要提起一个GUI系统必定包含一套图形库了。

> 当然，我们可以用纯纯的代码调用，向屏幕输出一条直线，一个正方形，一个黑色的圆。但，那要涉及巨量的代码，以及软硬件的问题。

那么图形库中必然包含如下一些内容：（基本与数据都是正相关的内容）
* 坐标系统：position，笛卡尔坐标，
* 点：point
* path，路径：用来实现数学意义上的线条与面积
    * 直线：一条路径，至少包含2个点。
    * 曲线：一条路径，加一个控制点，可以得到：贝塞尔曲线（也可以加2个控制点）
    * 面积：3个点，可以封闭一个区间，也就有了面积（三角形）
* 